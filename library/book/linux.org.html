<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux - my collection</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="AI.org.html"><strong aria-hidden="true">1.</strong> AI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MachineLearning.org.html"><strong aria-hidden="true">1.1.</strong> MachineLearning</a></li><li class="chapter-item expanded "><a href="DeepLearning.org.html"><strong aria-hidden="true">1.2.</strong> DeepLearning</a></li><li class="chapter-item expanded "><a href="NLP.org.html"><strong aria-hidden="true">1.3.</strong> NLP</a></li></ol></li><li class="chapter-item expanded "><a href="CS.org.html"><strong aria-hidden="true">2.</strong> CS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux.org.html" class="active"><strong aria-hidden="true">2.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="Algorithm.org.html"><strong aria-hidden="true">2.2.</strong> Algorithm</a></li><li class="chapter-item expanded "><a href="DataStructure.org.html"><strong aria-hidden="true">2.3.</strong> DataStructure</a></li><li class="chapter-item expanded "><a href="Parallelisum.org.html"><strong aria-hidden="true">2.4.</strong> Parallelisum</a></li><li class="chapter-item expanded "><a href="cloud_service_computing.org.html"><strong aria-hidden="true">2.5.</strong> Cloud_service_computing</a></li><li class="chapter-item expanded "><a href="blockchain.org.html"><strong aria-hidden="true">2.6.</strong> Blockchain</a></li></ol></li><li class="chapter-item expanded "><a href="DataScience.org.html"><strong aria-hidden="true">3.</strong> DataScience</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="DAMA.org.html"><strong aria-hidden="true">3.1.</strong> DAMA</a></li></ol></li><li class="chapter-item expanded "><a href="Math.org.html"><strong aria-hidden="true">4.</strong> Math</a></li><li class="chapter-item expanded "><a href="Physik.org.html"><strong aria-hidden="true">5.</strong> Physik</a></li><li class="chapter-item expanded "><a href="QutuamComputation.org.html"><strong aria-hidden="true">6.</strong> QutuamComputation</a></li><li class="chapter-item expanded "><a href="ROS.org.html"><strong aria-hidden="true">7.</strong> ROS</a></li><li class="chapter-item expanded "><a href="tools.org.html"><strong aria-hidden="true">8.</strong> Tools</a></li><li class="chapter-item expanded "><a href="WebDesign.org.html"><strong aria-hidden="true">9.</strong> WebDesign</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vue.org.html"><strong aria-hidden="true">9.1.</strong> Vue</a></li><li class="chapter-item expanded "><a href="vscode.org.html"><strong aria-hidden="true">9.2.</strong> Vscode</a></li></ol></li><li class="chapter-item expanded "><a href="Language.org.html"><strong aria-hidden="true">10.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c.org.html"><strong aria-hidden="true">10.1.</strong> C</a></li><li class="chapter-item expanded "><a href="ts.org.html"><strong aria-hidden="true">10.2.</strong> TS</a></li><li class="chapter-item expanded "><a href="scala.org.html"><strong aria-hidden="true">10.3.</strong> Scala</a></li><li class="chapter-item expanded "><a href="lisp.org.html"><strong aria-hidden="true">10.4.</strong> Lisp</a></li><li class="chapter-item expanded "><a href="Java.org.html"><strong aria-hidden="true">10.5.</strong> Java</a></li><li class="chapter-item expanded "><a href="JS.org.html"><strong aria-hidden="true">10.6.</strong> JS</a></li><li class="chapter-item expanded "><a href="go.org.html"><strong aria-hidden="true">10.7.</strong> Go</a></li><li class="chapter-item expanded "><a href="rust.org.html"><strong aria-hidden="true">10.8.</strong> Rust</a></li><li class="chapter-item expanded "><a href="python.org.html"><strong aria-hidden="true">10.9.</strong> Python</a></li><li class="chapter-item expanded "><a href="emacs.org.html"><strong aria-hidden="true">10.10.</strong> Emacs</a></li><li class="chapter-item expanded "><a href="haskell.org.html"><strong aria-hidden="true">10.11.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="Julia.org.html"><strong aria-hidden="true">10.12.</strong> Julia</a></li><li class="chapter-item expanded "><a href="mysql.org.html"><strong aria-hidden="true">10.13.</strong> Mysql</a></li><li class="chapter-item expanded "><a href="postgressql.org.html"><strong aria-hidden="true">10.14.</strong> Postgressql</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">my collection</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<hr />
<h2 id="title-linux"><a class="header" href="#title-linux">title: Linux</a></h2>
<pre><code class="language-{=org}">#+startup: content
</code></pre>
<h1 id="install"><a class="header" href="#install">Install</a></h1>
<h2 id="iso-installation"><a class="header" href="#iso-installation">ISO installation</a></h2>
<hr />
<p>lsblk   list all partiation
mkfs    format partiation
fdisk   manage partiation</p>
<hr />
<pre><code>lsblk
sudo umount....
format the partation: 
sudo mkfs -t ext4 /dev/sda1
sudo mkfs -t ext4 /dev/sda2
sudo mkfs -t ext4 /dev/sda
sudo dd if=.../ubuntu-20.04.3-desktop-amd64.iso of=/dev/sda bs=4M status=progress &amp;&amp; sync
resize the host
....
sudo mkfs -t ext4 /dev/sda
sudo fdisk -l
sudo fdisk  /dev/sda -&gt; m, g, n, 1, Enter, w

sudo dd if=/dev/nvm..p1 of=/dev/sda1
sudo dd if=/dev/nvm..p3 of=/dev/sda2


from windows: Rufus
Disk can delete all partation in linux 
lsblk -f
sudo mkfs -t ext4 /dev/sda
from Linux:
sudo dd if=~/Downloads/ubuntu-20.04.3-desktop-amd64.iso of=/dev/sda bs=4M status=progress &amp;&amp; sync
</code></pre>
<h2 id="backup-system"><a class="header" href="#backup-system">backup system</a></h2>
<p>one step to backup in USB</p>
<pre><code>sudo dd if=/dev/nvmxx2 of=/dev/sda2 bs=4M status=progress &amp;&amp; sync  
</code></pre>
<p>old setting insert SSD usb $ lsblk</p>
<pre><code class="language-example">check the partition of whole disk
</code></pre>
<p>$ sudo fdisk -l</p>
<pre><code class="language-example">check the detail partation
</code></pre>
<p>$ sudo mkfs -t ext4 /dev/sda</p>
<pre><code class="language-example">format sda  disk (can also for partition )
</code></pre>
<p>$ sudo fdisk /dev/sda</p>
<pre><code class="language-example">make new partiation distribation for backup
</code></pre>
<p>$ sudo dd if=/dev/nvmxx2 of=/dev/sda2 bs=4M status=progress &amp;&amp; sync</p>
<pre><code class="language-example">backup the whole system disk into sda2 backup partition
</code></pre>
<p>$ disk resize the restore partation</p>
<pre><code class="language-example">this step can open the Disks in APP, and resize the system disk,
better if the system disk is 10GB bigger than the backup partition.
Later for backup again, don't forget resize it back to backup again
</code></pre>
<p>$ sudo mkfs -t ext4 /dev/nvmxxx2</p>
<pre><code class="language-example">clean the system partition
</code></pre>
<p>$ sudo dd if=/dev/sda2 of=/dev/nvmxx2 bs=4M status=progress &amp;&amp; sync</p>
<pre><code class="language-example">should be just fine
</code></pre>
<h2 id="grub-repair"><a class="header" href="#grub-repair">grub repair</a></h2>
<p>for error : Minimal BASH-like line editing is supported......</p>
<pre><code>grub &gt; ls 
grub &gt; ls (hd0,gptXX)/boot/grub
</code></pre>
<p>if XX partation returns many file, one is with grub.cfg, this is the one
we want</p>
<pre><code>grub &gt; set root=(hd0,gptXX)
grub &gt; set prefix=(hd0,gptXX)/boot/grub
grub &gt; normal
</code></pre>
<p>enter the system</p>
<pre><code>sudo add-apt-repository ppa:yannubuntu/boot-repair
sudo apt-get update
sudo apt-get install boot-repair
sudo grub-install /dev/where EFI partation is
</code></pre>
<h2 id="recover-the-fastplatte-in-windows"><a class="header" href="#recover-the-fastplatte-in-windows">Recover the fastplatte in windows</a></h2>
<pre><code>1. WIN+R diskpart
2. select disk (Disk)
3. clean
4. new add 
</code></pre>
<h2 id="write-images-in-usb"><a class="header" href="#write-images-in-usb">write images in USB</a></h2>
<ol>
<li>下载ubuntu</li>
<li>下载USBwriter并安装</li>
<li>写入系</li>
</ol>
<h2 id="reboot"><a class="header" href="#reboot">reboot</a></h2>
<pre><code>my computer : F12
</code></pre>
<h2 id="update-nvidia-drivers-for-linux"><a class="header" href="#update-nvidia-drivers-for-linux">Update nvidia drivers for linux</a></h2>
<pre><code>sudo add-apt-repository ppa:graphics-drivers/ppa
sudo apt update 
ubuntu-drivers devices
sudo apt-get --reinstall install nvidia-430
    1.  will be asked for password
    2.  reboot
    3.  select Enroll MOK -&gt; continue -&gt; Yes -&gt; Roboot
nvidia-sim
watch -n 1 nvidia-smi
</code></pre>
<h2 id="chinese"><a class="header" href="#chinese">chinese</a></h2>
<p>export LC~CTYPE~=zh~CN~.UTF-8 sudo apt-get -y install
language-pack-zh-hans 此应用压制中英文的同步变化, 尽量避免使用中文</p>
<h2 id="time-screensaver"><a class="header" href="#time-screensaver">Time Screensaver</a></h2>
<p>NowSat Nov 5 12:29:50 2022, I just configured my computer for a time
screensaver.</p>
<ul>
<li>
<p><a href="https://github.com/alexanderk23/gluqlo">link</a></p>
</li>
<li>
<p>go the the link, for me only work with building from source, don't
forget the dependence.</p>
</li>
<li>
<p>after install it add following into ~/.xscreensaver under section
of programs:</p>
<pre><code>gluqlo -root \n\
</code></pre>
</li>
<li>
<p>install Xscreensaver if not with following, but before that, delete
gnome-screensaver if exist.</p>
<pre><code>sudo apt-get install xscreensaver xscreensaver-data-extra xscreensaver-gl-extra
</code></pre>
</li>
<li>
<p>start Screensaver application, find the Gluqlo, and set it to be the
only one, more setting is option</p>
</li>
<li>
<p>start startup application, add one as following, name and comment is
as well(liberty)command is this: xscreensaver -nosplash</p>
</li>
<li>
<p>lauch keyshort, add keyshort as following, key combination is as
personal wish</p>
<pre><code>xscreensaver-command -lock
</code></pre>
</li>
<li>
<p>change Wayland to xorg</p>
<ul>
<li>sudo apt install xorg</li>
<li>sudo nano /etc/gdm3/custom.conf</li>
<li>WaylandEnable=false</li>
</ul>
</li>
<li>
<p>now test the keyshort</p>
</li>
</ul>
<h1 id="system-configuration-collection"><a class="header" href="#system-configuration-collection">System configuration collection</a></h1>
<h2 id="check-port-of-application"><a class="header" href="#check-port-of-application">check port of application</a></h2>
<pre><code class="language-{.bash org-language=&quot;sh&quot; dir=&quot;/sudo::&quot; results=&quot;output&quot;}">ps -aux |grep mongo
netstat -nap |grep 80
</code></pre>
<h2 id="open-fire-wall-for-port"><a class="header" href="#open-fire-wall-for-port">open fire wall for port</a></h2>
<p>sudo apt install firewalld add port : sudo firewall-cmd
--add-port=80/tcp --permanent sudo firewall-cmd --remove-port=80/tcp
--permanent restart firewall: sudo firewall-cmd --reload check port:
sudo firewall-cmd --list-all</p>
<h2 id="firewall"><a class="header" href="#firewall">firewall</a></h2>
<p>systemctl status firewalld systemctl stop firewalld systemctl disable
firewalld systemctl enable firewalld</p>
<h2 id="shutdown-keyboard-default"><a class="header" href="#shutdown-keyboard-default">Shutdown Keyboard default</a></h2>
<pre><code>1. &lt;span class="katex"&gt;&lt;span class="katex-html" aria-hidden="true"&gt;&lt;span class="base"&gt;&lt;span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"&gt;&lt;/span&gt;&lt;span class="mord mathnormal"&gt;x&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;p&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.01968em;"&gt;tl&lt;/span&gt;&lt;span class="mord mathnormal"&gt;i&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.13889em;"&gt;tF&lt;/span&gt;&lt;span class="mord mathnormal"&gt;in&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;e&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.13889em;"&gt;T&lt;/span&gt;&lt;span class="mord mathnormal"&gt;o&lt;/span&gt;&lt;span class="mord mathnormal"&gt;u&lt;/span&gt;&lt;span class="mord mathnormal"&gt;c&lt;/span&gt;&lt;span class="mord mathnormal"&gt;h&lt;/span&gt;&lt;span class="mord mathnormal"&gt;p&lt;/span&gt;&lt;span class="mord mathnormal"&gt;a&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;an&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal"&gt;i&lt;/span&gt;&lt;span class="mord mathnormal"&gt;t&lt;/span&gt;&lt;span class="mord mathnormal"&gt;s&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.10903em;"&gt;N&lt;/span&gt;&lt;span class="mord mathnormal"&gt;A&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.05764em;"&gt;ME&lt;/span&gt;&lt;span class="mord mathnormal"&gt;an&lt;/span&gt;&lt;span class="mord mathnormal"&gt;d&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.07847em;"&gt;I&lt;/span&gt;&lt;span class="mord mathnormal" style="margin-right:0.02778em;"&gt;D&lt;/span&gt;&lt;span class="mord"&gt;2.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; xinput set-prop 'NAME' 'Device Enabled' 0
   to close the Touchpad
3. but with following can be named as tpOn and tpOff in ./bashrc
alias tpOff="xinput set-prop 'SYNA1D31:00 06CB:CD48 Touchpad' 'Device Enabled' 0"
alias tpOn="xinput set-prop 'SYNA1D31:00 06CB:CD48 Touchpad' 'Device Enabled' 1"
4. Close Touchpad default in boost system
   the following in ~/.config/autostart/xinput.desktop

[Desktop Entry]
Type=Application
Exec=xinput set-prop 'SYNA1D31:00 06CB:CD48 Touchpad' 'Device Enabled' 0
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name[zh_CN]=touchpad enable
Name=touchpad enable
</code></pre>
<h2 id="autostart"><a class="header" href="#autostart">autostart</a></h2>
<p>Thunderbird</p>
<pre><code>[Desktop Entry]
Type=Application
Exec=/usr/bin/thunderbird
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name[en_US]=thunderbird
Name=thunderbird
Comment[en_US]=thunderbird
Comment=thunderbird
</code></pre>
<h2 id="exchange-control-key-and-caps-key"><a class="header" href="#exchange-control-key-and-caps-key">exchange Control Key and Caps Key</a></h2>
<p>在/etc/default/keyboard文件中添加:</p>
<pre><code>XKBOPTIONS="ctrl:nocaps
</code></pre>
<p>or</p>
<pre><code class="language-shell">setxkbmap -option ctrl:nocaps
</code></pre>
<p>setting for 右键没反应 $ sudo add-apt-repository universe $ sudo apt
install gnome-tweak-tool</p>
<h2 id="right-key-no-response"><a class="header" href="#right-key-no-response">right key no response</a></h2>
<pre><code>gsettings set org.gnome.desktop.peripherals.touchpad click-method areas
</code></pre>
<h2 id="hotkey"><a class="header" href="#hotkey">hotkey</a></h2>
<hr />
<p>C-M- t   terminal
C-M- p   thunderbird
C-M- e   emacs
C-M- f   firefox
C-M- j   emacs windows switch
C-M- t   terminal
C-M- w   emacs worterbuch
C-M- t   terminal
C-M- t   terminal</p>
<hr />
<hr />
<p>Switch application                Alt + Tab
Switch window of an application   Alt + Spc</p>
<hr />
<hr />
<p>Alt Ctrl Del   退出用户</p>
<hr />
<p>in Einstellung, the executable command can be used in command for
customized hotkey</p>
<h2 id="clear-caches"><a class="header" href="#clear-caches">clear caches</a></h2>
<p>this command has been added to the .bashrc of the /root. only root user
can call this command</p>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">alias freemem="sync; echo 3 &gt; /proc/sys/vm/drop_caches &amp;&amp; swapoff -a &amp;&amp; swapon -a &amp;&amp; printf '\n%s\n' 'Ram-cache and Swap Cleared' "
</code></pre>
<h2 id="create-customized-dock-to-favorites"><a class="header" href="#create-customized-dock-to-favorites">create customized dock to favorites</a></h2>
<ul>
<li>
<p>find the executable files and icon</p>
</li>
<li>
<p>create the desktop setting file:
/usr/share/applications/myapp.desktop</p>
</li>
<li>
<p>change the settings and make it executable +x</p>
</li>
<li>
<p>new works as normal</p>
<pre><code class="language-shell">#!/usr/bin/env xdg-open
[Desktop Entry]
Version=1.0
Type=Application
Terminal=false
Exec=/path/to/yourapp
Name=YourApp
Comment=Description of YourApp
Icon=/path/to/yourapp.png
</code></pre>
</li>
</ul>
<h2 id="hstr"><a class="header" href="#hstr">hstr</a></h2>
<pre><code>add-apt-repository ppa:ultradvorka/ppa
apt-get update
apt-get install hstr
</code></pre>
<p>the hh</p>
<h1 id="commands"><a class="header" href="#commands">commands</a></h1>
<h2 id="hits"><a class="header" href="#hits">hits</a></h2>
<ul>
<li>assigne permition for delete</li>
</ul>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">chmod -R u+rwx /usr/users/szhao/go-workspace/pkg/mod
</code></pre>
<ul>
<li>/ect/ssh/sshd~config~
<ul>
<li>AllowedUsers cloud silin, allow such user login remotely</li>
</ul>
</li>
</ul>
<h2 id="terminal"><a class="header" href="#terminal">terminal</a></h2>
<p>S-C-c : can copy out from terminal S-C-v : can paste into terminal C-h :
backwards to delete C-j : enter C-k : cut after C-u : cut before</p>
<h2 id="sammary"><a class="header" href="#sammary">sammary</a></h2>
<pre><code>fdisk -l

fdisk /dev/nvme0n1p4 (m, p, n, ...)
mkfs.ext4 /dev/nvme0n1p4
sudo emacs /etc/fstab
/dev/nvme0n1p4 /home/silin/4GB ext4 defaults 0 0
</code></pre>
<p>in /etc/fstab, the command must be correct, otherwise the system can't
booted.</p>
<pre><code class="language-{.bash org-language=&quot;sh&quot; results=&quot;output&quot;}">cat &lt; source1.c &gt;&gt; source2.c (add source1.c to the end of source2.c)
</code></pre>
<p>echo $PATH | tr \: \<code>\n</code>{=latex}</p>
<h2 id="file-management"><a class="header" href="#file-management">file management</a></h2>
<p>在~内找filename的文件 find ~ -name filename</p>
<p>找到.bash~history内带有~"install"的内容 grep -n "install"
.bash~history~</p>
<p>copy 110.txt to 111.txt echo | cat 110.txt &gt; 111.txt</p>
<p>&gt; 擦除再写 &gt;&gt; 追加写入</p>
<p>读取.sdsv~history的不重复内容~，再写入到.sdsv echo | sort -n
.sdsv~history~ |uniq &gt; .sdsv</p>
<h2 id="directory-operation"><a class="header" href="#directory-operation">directory operation</a></h2>
<pre><code>tree -L 2
alias open='nautilus'
open .
</code></pre>
<h2 id="find-uninstall-and-remove-software"><a class="header" href="#find-uninstall-and-remove-software">find uninstall and remove software</a></h2>
<pre><code>sudo apt list --installed | grep software
whereis software
sudo apt-get --purge remove software
sudo apt-get autoremove
</code></pre>
<h2 id="su-password-config"><a class="header" href="#su-password-config">su password config</a></h2>
<p>sudo passwd :to configure the password of root user</p>
<h2 id="get-ip-address"><a class="header" href="#get-ip-address">get IP address</a></h2>
<p>curl ifconfig.me</p>
<h2 id="grep-sort"><a class="header" href="#grep-sort">grep sort</a></h2>
<p>grep -n "xxx" ./test.txt sort (--reverse -t " " -k 3 ) test.csv</p>
<h2 id="link"><a class="header" href="#link">link</a></h2>
<p>softlink</p>
<pre><code>ln -s filename linkname // 快捷方式
ln -s sourcefile softlinkname
filename加上绝对路径，linkname被移动后，仍能访问访问文件
</code></pre>
<p>hard link</p>
<pre><code>ln filename linkname   //硬链接
不占用磁盘空间，重复连接到文件的inode点。
可以在不同地方通过硬连接对文件进行操作
</code></pre>
<h2 id="cd-to-program-with-which"><a class="header" href="#cd-to-program-with-which">cd to program with which</a></h2>
<p>cd $(dirname $(which cling))</p>
<h2 id="awk"><a class="header" href="#awk">awk</a></h2>
<p>delete the repeat : awk '!a[$0]++' file.txt</p>
<h2 id="less"><a class="header" href="#less">less</a></h2>
<hr />
<p>J       down
K       up
Space   next page
b       previous page
/       search
n       next mark
N       previous mark
q       quit</p>
<hr />
<h2 id="link-1"><a class="header" href="#link-1">link</a></h2>
<h3 id="静态库的制作"><a class="header" href="#静态库的制作">静态库的制作</a></h3>
<ol>
<li>
<p>库方</p>
<p>include/head.h lib/ src/ 将在src/中编写要实现的文件 并编译这些文件
$ gcc *.c -c -I ../include/ -I :链接头文件 再将这些编译后的打包 $
ar rcs libtest.a *.o ar : -archive 打包 检测 : nm libtest.a 前缀lib
和后缀.a 不能更改，实际名字是test</p>
<p>最后将生成的libtest.a放到上级目录lib中，
可以将lib和include目录发送给甲方</p>
</li>
<li>
<p>甲方</p>
<p>根据include/head.h 的头文件编写自己的应用文件main.c
编译main.c并链接头文件和库 $ gcc main.c -I ./include/ -L ./lib/
-ltest -o app -I : 连接头文件 -L : 链接库 -ltest :
链接库文件，去头lib 去尾.a -o: 指点生成的应用名</p>
</li>
<li>
<p>特点</p>
<p>优点： 加载块，移植方便 缺点
：部署更新麻烦，引用的重复文件重复储存，浪费空间</p>
</li>
</ol>
<h3 id="动态库的制作"><a class="header" href="#动态库的制作">动态库的制作</a></h3>
<p>编译 $ gcc *.c -c -fpic -I ../include -fpic 或者 fPIC : 特殊命令 打包
$ gcc -shared *.o -o libxxx.so 头lib 尾.so</p>
<p>使用和静态库相似， 根据头文件编写应用文件main.c $ gcc main.c -I
./inculde/ -L ./lib/ -lxxx -o app</p>
<p>对于linux生成的文件都是elf格式，并由ld-libc.so动态加载,需要让app能别找
到可以用环境变量或者配置文件</p>
<ol>
<li>
<p>环境变量</p>
<p>临时设置 $ export LD~LIBRARYPATH~=./lib 或者新增 $ export
LD~LIBRARYPATH~=./lib:LD~LIBRARYPATH~</p>
<p>临时设置可以使用相对路径，</p>
<p>永久设置 用户 $ cat " LD~LIBRARYPATH~=./lib:LD~LIBRARYPATH~" &gt;&gt;
~/.bashrc $ source ~./bashrc</p>
<p>永久设置 系统 $ sudo cat "LD~LIBRARYPATH~=./lib:LD~LIBRARYPATH~"
&gt;&gt; /etc/profile $ source /etc/profile</p>
</li>
<li>
<p>修改配置文件</p>
<p>配置文件/etc/ld.so.conf $ sudo cat "绝对路径/lib" &gt;&gt;
/etc/ld.so.conf $ sudo ldconfig -v 激活配置</p>
</li>
<li>
<p>通过函数加载</p>
<p>dlopen dlclose dlsym</p>
</li>
</ol>
<h2 id="sshpass-login"><a class="header" href="#sshpass-login">sshpass login</a></h2>
<p>ssh user@ip sshpass -p password ssh user@ip</p>
<h2 id="login-without-password"><a class="header" href="#login-without-password">Login without password</a></h2>
<p>ssh-keygen -r rsa and drei mal enter ssh-copy-id cloud@ip ssh-copy-id
localhost(warming:username should not be hostname)</p>
<h2 id="ssh-root-login"><a class="header" href="#ssh-root-login">ssh root login</a></h2>
<p>emacs /etc/ssh/sshd~config~</p>
<ol>
<li>PermitRootLogin yes</li>
<li>AllowUsers root OtherUser</li>
</ol>
<h2 id="output-redirect"><a class="header" href="#output-redirect">output redirect</a></h2>
<p>comands xxx &gt;&gt; output file comands xxx &amp;&gt;&gt; str error file</p>
<h2 id="recursive-string-replace"><a class="header" href="#recursive-string-replace">recursive string replace</a></h2>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">find . -type f -name "*.md" -exec sed -i 's/foo/bar/g' {} +
find . -type f -name "*.vue" -exec sed -i 's/store.state.Timer/store.state.Session01/g' {} +
</code></pre>
<h1 id="useful-software"><a class="header" href="#useful-software">Useful Software</a></h1>
<h2 id="tar"><a class="header" href="#tar">tar</a></h2>
<p>-x : extract -c: compose -v: show the process -z: with zip -f : such
file</p>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">tar -zvcf xxx.tar.gz xxx
tar -zvxf xxx.tar.gz
</code></pre>
<h2 id="fcitx-for-sougou"><a class="header" href="#fcitx-for-sougou">fcitx for sougou</a></h2>
<pre><code>1. sudo apt install fcitx
download sougou
2. sudo apt  --fix-broken install(after download)
3. export LC_CTYPE=zh_CN.UTF-8 (for Emacs)
</code></pre>
<h2 id="eog"><a class="header" href="#eog">eog</a></h2>
<pre><code>eog xxx.png to view png with bluit in software eog
</code></pre>
<h2 id="okular"><a class="header" href="#okular">Okular</a></h2>
<pre><code>sudo apt-get install okular
F2 to constimizer
F7 mode view
C-gg to the page
C-n page down
C-p page up
M-n scroll down
M-p scroll up
C-b C-b add Annoation, 1 to note
SPC-b add bookmark
SPC-SPC rename bookmark
SPC-n bookmark down
SPC-p bookmark up
</code></pre>
<h2 id="xournal"><a class="header" href="#xournal">xournal</a></h2>
<pre><code>sudo apt install xournal
</code></pre>
<h2 id="evince"><a class="header" href="#evince">evince</a></h2>
<pre><code>evince xxx.pdf to view pdf file
</code></pre>
<h2 id="stardict"><a class="header" href="#stardict">stardict</a></h2>
<p>download dictionaries from, <a href="http://download.huzheng.org/">http://download.huzheng.org/</a> and
<a href="http://download.huzheng.org/zh_TW/">http://download.huzheng.org/zh_TW/</a> extract, and put them in
<em>usr/share/stardict/dic</em> , if without this folder, create it with root</p>
<pre><code class="language-shell">sudo apt install stardict
sudo apt install sdcv 
cd ~/Dropbox/cs/Tools
bzip2 -dk *.bz2
for i in *.tar.bz2; do sudo tar -xjvf "$i" -C /usr/share/stardict/dic ; done

</code></pre>
<h2 id="kmplayer"><a class="header" href="#kmplayer">kmplayer</a></h2>
<p>sudo apt install kmplayer</p>
<h2 id="simplescreenrecorder"><a class="header" href="#simplescreenrecorder">simplescreenrecorder</a></h2>
<pre><code>sudo apt install simplescreenrecorder
alias ssr='simplescreenrecorder'
 ssr
Ctrl + Shift + Alt + V start or pause 
</code></pre>
<h2 id="cvim"><a class="header" href="#cvim">Cvim</a></h2>
<pre><code>C-j moive to left 
C-k moive to right
</code></pre>
<h2 id="hotopea"><a class="header" href="#hotopea">hotopea</a></h2>
<p>登陆photopea网站后，新建并上传图片 设置白色背景：图像 -&gt; 调整 -&gt; 色阶
点击下面的白色 后点击要处理的图片区域 去背景 ： 魔术棒 ， 点击去连续，
再直接delete</p>
<h2 id="manual-png-create-png"><a class="header" href="#manual-png-create-png">manual png create png</a></h2>
<p>after edit a file.dot</p>
<p>dot -Tpng -O file.dot</p>
<h2 id="gpg-for-secret"><a class="header" href="#gpg-for-secret">gpg for secret</a></h2>
<pre><code>gpg --list-secret-keys
gpg -r user -e xxx.file
gpg -d xxx.file.gpg
after change xxx.file :gpg --verify xxx.file.gpg
</code></pre>
<h2 id="ranger"><a class="header" href="#ranger">ranger</a></h2>
<p>apt install</p>
<h2 id="pdftk"><a class="header" href="#pdftk">pdftk</a></h2>
<p><a href="http://www.pdflabs.com/docs/install-pdftk/">official web link</a></p>
<hr />
<p>合并               pdftk 1.pdf 2.pdf 3.pdf output 123.pdf
多个不同页面合并   pdftk A=1.pdf B=2.pdf C=pdf cat A1-2 B2-3 C3 output abc.pdf
旋转第一页         pdftk in.pdf cat 1E 2-end output out.pdf
加密（128位）      pdftk a.pdf output b.pdf owner~pw~ pass
加访问密码         pdftk a.pdf output b.pdf user~pw~ pass
解密               pdftk a.pdf input~pw~ pass output b.pdf
解压               pdftk a.pdf output b.pdf uncompress
压缩               pdftk a.pdf output b.pdf compress
修复               pdftk a.pdf output b.pdf
切割               pdftk a.pdf cat 1-end output b.pdf
分解成单页         pdftk a.pdf burst</p>
<hr />
<h2 id="linux-connect-to-android"><a class="header" href="#linux-connect-to-android">Linux connect to Android</a></h2>
<pre><code>kedconnect on linux
kedconnect on android
with  the same internet connection can be found each other, and communication

The file can be found in Download folder of each devices
</code></pre>
<h2 id="gs"><a class="header" href="#gs">gs</a></h2>
<h3 id="remove-active-content-from-pdf"><a class="header" href="#remove-active-content-from-pdf">remove active content from pdf</a></h3>
<p>gs -dNOPAUSE -sDEVICE=pdfwrite -sOUTPUTFILE=CV.pdf -dBATCH CV.pdf</p>
<h3 id="compress"><a class="header" href="#compress">compress</a></h3>
<p>gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/prepress
-dNOPAUSE -dQUIET -dBATCH -sOutputFile=compressed~PDFfile~.pdf
input~PDFfile~.pdf</p>
<h2 id="mpv-player"><a class="header" href="#mpv-player">mpv player</a></h2>
<p>sudo apt install mpv</p>
<p>mpv.conf</p>
<pre><code>no-osd-bar # 去掉白色进度条
save-position-on-quit # 关闭时记住文件播放位置
no-border # 去掉边框

# 解码-字幕
vo=opengl:gamma-auto:icc-profile-auto
hwdec=auto
autofit-larger=92%
playcache=8192
lang=zh,chi
video-sync=display-resample

sub-codepage=enca:zh:utf8
sub-auto=fuzzy
sub-text-font-size=40
sub-text-shadow-offset=0
sub-text-color="#ffffffff"
sub-text-font="STZhongsong"
sub-codepage=utf8:gb18030

screenshot-template=mpv-screenshot-%f-%p
screenshot-format=png

osd-font="STZhongsong"
osd-font-size=36

--script=/Users/yourname/.config/mpv/autoload.lua
</code></pre>
<p>autoload.lua</p>
<pre><code>-- This script automatically loads playlist entries before and after the
-- the currently played file. It does so by scanning the directory a file is
-- located in when starting playback. It sorts the directory entries
-- alphabetically, and adds entries before and after the current file to
-- the internal playlist. (It stops if the it would add an already existing
-- playlist entry at the same position - this makes it "stable".)
-- Add at most 5000 * 2 files when starting a file (before + after).
MAXENTRIES = 5000

function Set (t)
    local set = {}
    for _, v in pairs(t) do set[v] = true end
    return set
end

EXTENSIONS = Set {
    'mkv', 'avi', 'mp4', 'ogv', 'webm', 'rmvb', 'flv', 'wmv', 'mpeg', 'mpg', 'm4v', '3gp',
    'mp3', 'wav', 'ogv', 'flac', 'm4a', 'wma',
}

mputils = require 'mp.utils'

function add_files_at(index, files)
    index = index - 1
    local oldcount = mp.get_property_number("playlist-count", 1)
    for i = 1, #files do
        mp.commandv("loadfile", files[i], "append")
        mp.commandv("playlist-move", oldcount + i - 1, index + i - 1)
    end
end

function get_extension(path)
    match = string.match(path, "%.([^%.]+)" )
    if match == nil then
        return "nomatch"
    else
        return match
    end
end

table.filter = function(t, iter)
    for i = #t, 1, -1 do
        if not iter(t[i]) then
            table.remove(t, i)
        end
    end
end

function find_and_add_entries()
    local path = mp.get_property("path", "")
    local dir, filename = mputils.split_path(path)
    if #dir == 0 then
        return
    end
    local pl_count = mp.get_property_number("playlist-count", 1)
    if (pl_count &gt; 1 and autoload == nil) or
       (pl_count == 1 and EXTENSIONS[string.lower(get_extension(filename))] == nil) then
        return
    else
        autoload = true
    end

    local files = mputils.readdir(dir, "files")
    if files == nil then
        return
    end
    table.filter(files, function (v, k)
        local ext = get_extension(v)
        if ext == nil then
            return false
        end
        return EXTENSIONS[string.lower(ext)]
    end)
    table.sort(files, function (a, b)
        local len = string.len(a) - string.len(b)
        if len ~= 0 then -- case for ordering filename ending with such as X.Y.Z
            local ext = string.len(get_extension(a)) + 1
            return string.sub(a, 1, -ext) &lt; string.sub(b, 1, -ext)
        end
        return string.lower(a) &lt; string.lower(b)
    end)

    if dir == "." then
        dir = ""
    end

    local pl = mp.get_property_native("playlist", {})
    local pl_current = mp.get_property_number("playlist-pos", 0) + 1
    -- Find the current pl entry (dir+"/"+filename) in the sorted dir list
    local current
    for i = 1, #files do
        if files[i] == filename then
            current = i
            break
        end
    end
    if current == nil then
        return
    end

    local append = {[-1] = {}, [1] = {}}
    for direction = -1, 1, 2 do -- 2 iterations, with direction = -1 and +1
        for i = 1, MAXENTRIES do
            local file = files[current + i * direction]
            local pl_e = pl[pl_current + i * direction]
            if file == nil or file[1] == "." then
                break
            end

            local filepath = dir .. file
            if pl_e then
                -- If there's a playlist entry, and it's the same file, stop.
                if pl_e.filename == filepath then
                    break
                end
            end

            if direction == -1 then
                if pl_current == 1 then -- never add additional entries in the middle
                    mp.msg.info("Prepending " .. file)
                    table.insert(append[-1], 1, filepath)
                end
            else
                mp.msg.info("Adding " .. file)
                table.insert(append[1], filepath)
            end
        end
    end

    add_files_at(pl_current + 1, append[1])
    add_files_at(pl_current, append[-1])
end

mp.register_event("start-file", find_and_add_entries)
</code></pre>
<h2 id="mellplayer"><a class="header" href="#mellplayer">mellplayer</a></h2>
<p>sudo apt-get install libmpv-dev mpv</p>
<h2 id="thunderbird"><a class="header" href="#thunderbird">thunderbird</a></h2>
<pre><code>Alt to open the menubar,
Ansicht Anpassen to setting ungelesen

For Filter:
cd ~/.thunderbird/4r373mm9.default-release/ImapMail/imap.gmail.com
import msgFilterRules.dat to Gmail
</code></pre>
<h2 id="eversync"><a class="header" href="#eversync">EverSync</a></h2>
<p>Eversync sync all bookmarks between chrome and firefox with G Konten</p>
<h2 id="ipfs"><a class="header" href="#ipfs">IPFS</a></h2>
<pre><code>download go-ipfs and untar
cp ipfs /usr/local/bin and sudo ./install.sh

sudo apt install ipfs

ipfs init
export EDITOR=/usr/bin/emacs
ipfs config edit
ipfs id
ipfs  help


mkdir IPFS
echo "balabalu" &gt; hallo.org
ipfs add hallo.org  :get file_hash
ipfs cat file_hash
ipfs.io/ipfs/file_hash
</code></pre>
<p>push</p>
<pre><code>ipfs add -r . (we get all file_hash(s), and a folder_hash(IPFS))
ipfs name publish folder_hash  (: to IDHASH)

in Webborser: ipfs.io/ipns/IDHASH


ipfs name resolve IDHASH : to HASH_file

特殊加密，暂时不用
ipfs key gen --type=rsa --size=2048 IPFS
ipfs name publish --key=IPFS folder_hash

ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST","OPTIONS"]'

ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]'

ipfs config --json API.HTTPHeaders.Access-Control-Allow-Credentials '["true"]'

ipfs config --json API.HTTPHeaders.Access-Control-Allow-Headers '["Authorization"]'

ipfs config --json API.HTTPHeaders.Access-Control-Expose-Headers '["Location"]'


http://localhost:5001/webui


ipfs files mkdir /Docu

ipfs files ls /Docu

ipfs file cp /ipfs/HASH
</code></pre>
<h2 id="gpg"><a class="header" href="#gpg">GPG</a></h2>
<hr />
<p>terminal encrypt   gpg --recipient ID --output en.org --encrypt source.org
terminal decrypt   gpg en.org
emacs encrypt      epa-encrypt-file
emacs decrypt      epa-decrypt-file</p>
<hr />
<p>encrypt by terminal, once decrypt by emacs, just as normal file, can be
edited anytime encrypt by emacs with password, passwd will be ask every
time by after edit if epa-file-select-key is t</p>
<h2 id="zulip-rocket-chat"><a class="header" href="#zulip-rocket-chat">Zulip Rocket Chat</a></h2>
<h1 id="system-control"><a class="header" href="#system-control">System control</a></h1>
<h2 id="system-backup"><a class="header" href="#system-backup">system backup</a></h2>
<p>mount rsync</p>
<p>查看系统的磁盘 :lsblk 再将磁盘(也可以是某个分区)挂载到某个点 :</p>
<p>该磁盘可以是正在使用的磁盘或者分区</p>
<pre><code> mount /dev/disk /media/Linux
sudo mount /dev/sda1 /media/Backup

rsync -aAXv --delete --exclude=media target backup/LinuxBackUp20200316
my opera 

rsync -aAXv /home/sx/ /media/sx/A672BA1B72B9EFE3/linuxbackup/home/
</code></pre>
<p>如果要恢复，重复上面的过程，再将target backup 交换</p>
<h2 id="system-performance"><a class="header" href="#system-performance">system performance</a></h2>
<ol>
<li>
<p>systemlastanzeigen sudo apt install indicator-multiload</p>
</li>
<li>
<p>dependence</p>
</li>
</ol>
<p>sudo apt-get install gir1.2-gtop-2.0 gir1.2-networkmanager-1.0
gir1.2-clutter-1.0</p>
<ol>
<li>Ubuntu Software</li>
</ol>
<p>search for : system moniter extension</p>
<ol>
<li>install and configure performance</li>
</ol>
<h2 id="hostname"><a class="header" href="#hostname">hostname</a></h2>
<p>hostnamectl hostnamectl set-hostname cat /etc/hostname cat /etc/hosts</p>
<h1 id="chinese-config"><a class="header" href="#chinese-config">chinese config</a></h1>
<h2 id="emacs-chinese-input"><a class="header" href="#emacs-chinese-input">emacs chinese input</a></h2>
<p>sudo apt install fcitx download sougou for linux sudo dpkg -i
sougou...... fcitx set global restart configuration to add sougou
chinese</p>
<p>$ local -a |grep zh sudo apt-get -y install language-pack-zh-hans $
local -a |grep zh to see zh is installed</p>
<p>export LC~CTYPE~=zh~CN~.UTF-8 to language configuration and auto install
drivers to zh~CN~.UTF-8 so in emacs can input sougou, here we go</p>
<h2 id="chinese-output-pdf"><a class="header" href="#chinese-output-pdf">chinese output pdf</a></h2>
<p>for a orgmode file with 汉字 pandoc xxxx.org -o xxxx.pdf pandoc xxxx.org
-o xxxx.pdf --pdf-engine=xelatex 如果没有汉字支持</p>
<pre><code>fc-list -f "%{family}\n"  :lang=zh
pandoc test.org -o test.pdf --pdf-engine=xelatex -V mainfont="AR PL KaitiM GB"
</code></pre>
<p>找到支持的格式，再指明</p>
<h1 id="sed"><a class="header" href="#sed">sed</a></h1>
<hr />
<p>a   add new line(s) after match with context behind a
c   replace the current line in match with context behind c
i   add context behind i before match
s   repace
d   delete</p>
<hr />
<p>sed -rn '/2\/1/s/00/**/pg' test2.csv</p>
<ul>
<li>sed:</li>
<li>-rn : no default output and allow \</li>
<li>' ' : aufrufen</li>
<li>/2\/1: reg pattern</li>
<li>s: search</li>
<li>00: all 00</li>
</ul>
<p>-<strong>**</strong>: will be replaced by**</p>
<ul>
<li>p: print</li>
<li>g: global replace</li>
<li>test2.csv: input file</li>
</ul>
<p>sed 's/ //pg' test2.csv</p>
<h1 id="makefile"><a class="header" href="#makefile">Makefile</a></h1>
<p>gcc 调用 make 来构造</p>
<h2 id="格式"><a class="header" href="#格式">格式</a></h2>
<p>目标 ： 依赖 Tab 命令</p>
<h2 id="1example"><a class="header" href="#1example">1example</a></h2>
<p>实列文件：add.c head.h main.c maul.c sub.c 直接在terminal 用gcc ：$ gcc
add.c main.c sub.c -o app</p>
<p>Makefile : $ touch Makefile</p>
<pre><code class="language-txt">app: main.c add.c sub.c mul.c
    gcc main.c add.c sub.c mul.c 
</code></pre>
<p>$ make</p>
<h2 id="2修改后只编译改动后的文件"><a class="header" href="#2修改后只编译改动后的文件">2修改后只编译改动后的文件</a></h2>
<p>Makefile : $ touch Makefile</p>
<pre><code class="language-txt">app: main.o add.o sub.o mul.o
    gcc main.o add.o sub.o mul.o -o app

main.o: main.c
    gcc -c main.c -o main.o

add.o: add.c
    gcc -c add.c -o add.o

sub.o: sub.c
    gcc -c sub.c -o sub.o

mul.o: mul.c
    gcc -c mul.c -o mul.o

</code></pre>
<p>$ make 所有源文件的修改过，即时间戳晚于生成的目标文件，则重新编译</p>
<h2 id="3使用自动变量"><a class="header" href="#3使用自动变量">3使用自动变量</a></h2>
<p>$@ :目标 $&lt; :第一个依赖 $^ :所有依赖 Makefile : $ touch Makefile</p>
<pre><code class="language-txt">obj =   main.o add.o sub.o mul.o
target = app

$(target):$(obj)
    gcc $(obj) -o $(target)  // gcc $^ -o $@

%.o:%.c
    gcc -c $&lt; -o $@

</code></pre>
<p>$ make</p>
<h2 id="4增加可移植性"><a class="header" href="#4增加可移植性">4增加可移植性</a></h2>
<p>wildcard :查找指定目录下的指定类型文件 src = $(wildcard ./*.c)
将当前目录下所有的.c 找到，并赋给src</p>
<p>patsubst :匹配替换 obj = $(patsubst %.c, %.o, $(src))
将src中的所有.c替换为.o</p>
<p>Makefile : $ touch Makefile</p>
<pre><code class="language-txt">src = $(wildcard ./*.c)
obj = $(patsubst %.c, %.o $(src))
target = app

$(target):$(obj)
    gcc $^ -o $@

%.o:%.c
    gcc -c $&lt; -o $@

</code></pre>
<p>$ make 此文件在别的目录下也能使用</p>
<h2 id="5清洁中间的生成的不必要保存文件"><a class="header" href="#5清洁中间的生成的不必要保存文件">5清洁中间的生成的不必要保存文件</a></h2>
<p>make 一般直接执行终结目标，但是可以直接指定make的函数 clean :
删除不必要的文件，-f : 强制删除，不管有没有该文件，- :
前置-后，遇到错误执行，直接跳过</p>
<pre><code class="language-txt">src = $(wildcard ./*.c)
obj = $(patsubst %.c, %.o $(src))
target = app

$(target):$(obj)
    gcc $^ -o $@

%.o:%.c
    gcc -c $&lt; -o $@

clean:
    rm $(obj) $(target)
    rm $(obj) $(target) -f
    -rm $(obj) $(target) -f

</code></pre>
<p>$ make $ make clean</p>
<h1 id="betreibensystem"><a class="header" href="#betreibensystem">BetreibenSystem</a></h1>
<h2 id="program-execution-level"><a class="header" href="#program-execution-level">Program execution level</a></h2>
<p>Multi Process : Parallel single Process has more thread : Concurrency
single thread can work in Synchronous or Asynchronous</p>
<h2 id="multi-process"><a class="header" href="#multi-process">Multi Process</a></h2>
<h3 id="queue-communication"><a class="header" href="#queue-communication">queue communication</a></h3>
<ol>
<li>
<p>one way communication server to client</p>
<p>Server.c</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"
#include "string.h"

#define messagelen 124


struct messqueue
{
  long type;
  char message[messagelen];
  char ID[4];
};


int main(int argc, char *argv[])
{
  int msgid;
  int key;
  int receivelen;
  int conut = 0;
  struct messqueue sendbuffer;
  sendbuffer.type = 100;

  key = ftok("./a.c", 'a');
  if (key &lt; 0) {
    printf("create key for server failed \n");
    return -1;
  }

  //create the massage queue
  msgid= msgget(key, IPC_CREAT | 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }
  printf("create massage queue success  with msgid %d.\n",  msgid);


  do {
    memset(sendbuffer.message, 0, messagelen);
    //input your massage
    printf("please input your massage you want to send to massage queue \n");
    scanf("%s", sendbuffer.message);

    //wirte the massage(which is now in your struct messqueue) into massage queue msgid
    msgsnd(msgid, (void *)&amp;sendbuffer, strlen(sendbuffer.message), 0);
    conut++;
  }while (conut &lt; 3);

  msgctl(msgid, IPC_RMID, NULL);

  system("ipcs -q");
  return 0;
}

</code></pre>
<p>Client.C</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"
#include "string.h"

#define messagelen 124


struct messqueue
{
  long type;
  char message[messagelen];
  char ID[4];
};


int main(int argc, char *argv[])
{
  int msgid;
  int key;
  int receivelen;
  int conut = 0;
  struct messqueue sendbuffer;
  sendbuffer.type = 100;

  key = ftok("./a.c", 'a');
  if (key &lt; 0) {
    printf("create key for server failed \n");
    return -1;
  }

  //create the massage queue
  msgid= msgget(key, IPC_CREAT | 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }
  printf("create massage queue success  with msgid %d.\n",  msgid);


  do {
    memset(sendbuffer.message, 0, messagelen);
    //input your massage
    printf("please input your massage you want to send to massage queue \n");
    scanf("%s", sendbuffer.message);

    //wirte the massage(which is now in your struct messqueue) into massage queue msgid
    msgsnd(msgid, (void *)&amp;sendbuffer, strlen(sendbuffer.message), 0);
    conut++;
  }while (conut &lt; 3);

  msgctl(msgid, IPC_RMID, NULL);

  system("ipcs -q");
  return 0;
}

</code></pre>
</li>
<li>
<p>two ways communication server vs client</p>
<p>Server.c</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"
#include "string.h"

#define messagelen 124


struct messqueue
{
  long type;
  char message[messagelen];
  char ID[4];
};


int main(int argc, char *argv[])
{
  int msgid;
  int key;
  int receivelen;
  int conut = 0;
  pid_t pid;
  struct messqueue sendbuffer, receiverbuffer;


  key = ftok("./b.c", 'a');
  if (key &lt; 0) {
    printf("create key for server failed \n");
    return -1;
  }

  //create the massage queue
  msgid= msgget(key, IPC_CREAT | 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }
  printf("create massage queue success  with msgid %d.\n",  msgid);

  pid = fork();

  if (pid &gt; 0) {   //server father process write tpye 100
    sendbuffer.type = 100;

    while(1) {
      memset(sendbuffer.message, 0, messagelen);
      //input your massage
      printf("please input your massage you want to send to massage queue \n");
      scanf("%s", sendbuffer.message);

      //wirte the massage(which is now in your struct messqueue) into massage queue msgid
      msgsnd(msgid, (void *)&amp;sendbuffer, strlen(sendbuffer.message), 0);
      conut++;
    }
  }

  if (pid == 0) {    //server child process read tpye 200
    while (1) {
      memset(receiverbuffer.message, 0, messagelen);
      msgrcv(msgid, (void *)&amp;receiverbuffer, messagelen, 200, 0);
      printf("the receive massage of massage queue in server is %s \n", receiverbuffer.message);
    }

  }

  msgctl(msgid, IPC_RMID, NULL);

  system("ipcs -q");
  return 0;
}

</code></pre>
<p>Client.c</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"
#include "string.h"

#define messagelen 124


struct messqueue
{
  long type;
  char message[messagelen];
  char ID[4];
};


int main(int argc, char *argv[])
{
  int msgid;
  int key;
  int receivelen;
  int conut = 0;
  pid_t pid;
  struct messqueue sendbuffer, receiverbuffer;


  key = ftok("./b.c", 'a');
  if (key &lt; 0) {
    printf("create key for server failed \n");
    return -1;
  }

  //create the massage queue
  msgid= msgget(key, IPC_CREAT | 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }
  printf("create massage queue success  with msgid %d.\n",  msgid);

  pid = fork();

  if (pid == 0) { // client child process for write tpye 200
    sendbuffer.type = 200;

    while(1) {
      memset(sendbuffer.message, 0, messagelen);
      //input your massage
      printf("please input your massage you want to send to massage queue \n");
      scanf("%s", sendbuffer.message);

      //wirte the massage(which is now in your struct messqueue) into massage queue msgid
      msgsnd(msgid, (void *)&amp;sendbuffer, strlen(sendbuffer.message), 0);
      conut++;
    }
  }

  if (pid &gt; 0) {  // client child process read type 100
    while(1){
      memset(receiverbuffer.message, 0, messagelen);
      msgrcv(msgid, (void *)&amp;receiverbuffer, messagelen, 100, 0);
      printf("the receive massage of massage queue in server is %s \n", receiverbuffer.message);
    }
  }

  msgctl(msgid, IPC_RMID, NULL);

  system("ipcs -q");
  return 0;
}


</code></pre>
</li>
</ol>
<h3 id="pipe-communication"><a class="header" href="#pipe-communication">pipe communication</a></h3>
<ol>
<li>
<p>named</p>
<ol>
<li>In current directory: mkfifo("./myfifo", 0777);</li>
</ol>
<p>with mkfifo creat a file, so that other unrelated process can commu</p>
<ol>
<li>In one process : fd = open("./myfifo", O~WRONGLY~);</li>
</ol>
<p>open the file, and : write(fd, &amp;process~inter~,1); change the pipe
variable.</p>
<ol>
<li>In other process : fd = open("./myfifo",O~RDONLY~);</li>
</ol>
<p>open the file, and : while(process~inter~ == 0); can be controled by
pipe variable</p>
</li>
<li>
<p>unnamed</p>
<ol>
<li>
<p>In one process diff threads creat place for pipe : int fd[2];
one for main thread, one for new thread creat pipe : int ret =
pipe(fd);</p>
<p>in new thread : read(fd[0], &amp;process~inter~ 1); if nothing to
read, sleep in main thread do its stuff, after finish :
write(fd[1], &amp;process~inter~, 1); let new pthread run</p>
<p>remeber: wirte at frist in fd[1], and then read at fd[0]</p>
</li>
</ol>
</li>
</ol>
<h3 id="signal-communication"><a class="header" href="#signal-communication">signal communication</a></h3>
<ol>
<li>
<p>alarm</p>
<p>alarm(10); wait for 10 seconds and kill itself send signal as 14 to
itself</p>
</li>
<li>
<p>kill</p>
<p>kill(pid, 9); send signal 9 to pid process</p>
</li>
<li>
<p>raise</p>
<p>raise(9); == kill(getpid(), 9);</p>
</li>
<li>
<p>pause</p>
<p>pause(); stoped for ever</p>
</li>
<li>
<p>signal</p>
<p>signal(signal~ID~, self~function~); self function or SIG~ING~ or
SIG~DFL~</p>
</li>
<li>
<p>exit</p>
<p>exit(0) will also send signal 17 (SIGCHID) to its father thread;</p>
</li>
</ol>
<h3 id="semaphore-communication"><a class="header" href="#semaphore-communication">semaphore communication</a></h3>
<ol>
<li>
<p>key</p>
<p>key can be 2 differ</p>
<ol>
<li>For father and son process : IPC~PRIVATE~ :</li>
<li>For unrelated process : self~def~ key</li>
</ol>
<pre><code class="language-{.c org-language=&quot;C&quot; results=&quot;output&quot; exports=&quot;both&quot;}">
int key;
key = ftok("./a.c", 'a');
if (key &lt; 0) {
  printf("create key for server failed \n");
  return -1;
}
printf("create key for server success \n");
</code></pre>
</li>
<li>
<p>memcpy</p>
<p>memcpy(p, "niao",4);</p>
</li>
<li>
<p>shmget</p>
<p>shmid = shmget(IPC~PRIVATE~, 128, 0777); shmid = shmget(key, 128,
IPC~CREAT~ | 0777);</p>
</li>
<li>
<p>shmat</p>
<p>char *p = (char *) shmat(shmid, NULL, 0); after mapping to p : can
be manipulated scanf("%s", p); printf("%s", p);</p>
</li>
<li>
<p>shmdt</p>
<p>delete the mapping of p to shared memory shmdt(p); after that, the
manipulation of p is not allowed, and well be segmention fault</p>
</li>
<li>
<p>shmctl</p>
<p>delete the created shared memory shmctl(shmid, IPC~RMID~, NULL); ==
iprcm -m shmid</p>
</li>
<li>
<p>IPC manipulation</p>
<p>show : ipcs -m(shared memory) -q(message queue) -s(semaphores)
delete : ipcrm -m shmid /-q msgid /-s semid</p>
</li>
<li>
<p>msgget</p>
<p>msgid= msgget(IPC~PRIVATE~, 0777);</p>
<pre><code class="language-{.c org-language=&quot;C&quot; results=&quot;output&quot; exports=&quot;both&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"

int main(int argc, char *argv[])
{
  int msgid;

  msgid= msgget(IPC_PRIVATE, 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }

  printf("create massage queue success  with msgid %d.\n",  msgid);

  system("ipcs -q");
  return 0;
}

</code></pre>
<pre><code class="language-example">
------ Nachrichtenwarteschlangen --------
Schlüssel msqid      Besitzer   Rechte     Benutzt-Bytes Nachrichten 
0x61091797 2          silin      777        0            0           
0x00000000 4          silin      777        0            0           
0x00000000 5          silin      777        0            0           
0x00000000 6          silin      777        0            0           
0x00000000 7          silin      777        0            0           
0x00000000 8          silin      777        0            0           
0x00000000 9          silin      777        0            0           
0x00000000 10         silin      777        0            0           
0x00000000 11         silin      777        0            0           
0x00000000 12         silin      777        0            0           

create massage queue success  with msgid 12.
</code></pre>
</li>
<li>
<p>msgctl</p>
<p>msgctl(msgid, IPC~RMID~, NULL); == ipcrm -q msgid</p>
<pre><code class="language-{.c org-language=&quot;C&quot; results=&quot;output&quot; exports=&quot;both&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"

int main(int argc, char *argv[])
{
  int msgid;

  msgid= msgget(IPC_PRIVATE, 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }

  printf("create massage queue success  with msgid %d.\n",  msgid);

  system("ipcs -q");
  return 0;
}

</code></pre>
</li>
<li>
<p>msgsnd &amp; msgrcv</p>
<p>msgsnd(msgid, (void *)&amp;sendbuffer, strlen(sendbuffer.message), 0);</p>
<p>receivelen = msgrcv(msgid, (void *)&amp;receiverbuffer, messagelen,
100, 0);</p>
<pre><code class="language-{.c org-language=&quot;C&quot; results=&quot;output&quot; exports=&quot;both&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"
#include "string.h"

#define messagelen 124


struct messqueue
{
  long type;
  char message[messagelen];
  char ID[4];
};


int main(int argc, char *argv[])
{
  int msgid;
  int receivelen;
  struct messqueue sendbuffer, receiverbuffer;
  sendbuffer.type = 100;
  receiverbuffer.type = 100;

  //create the massage queue
  msgid= msgget(IPC_PRIVATE, 0777);
  if (msgid &lt; 0) {
    printf("creat massage queue failed .\n");
    return -1;
  }
  printf("create massage queue success  with msgid %d.\n",  msgid);

  //input your massage
  printf("please input your massage you want to send to massage queue \n");
  scanf("%s", sendbuffer.message);

  //wirte the massage(which is now in your struct messqueue) into massage queue msgid
  msgsnd(msgid, (void *)&amp;sendbuffer, strlen(sendbuffer.message), 0);

  //clear receiverbuffer.massage
  memset(receiverbuffer.message, 0, messagelen);
  //read massage to receiverbuffer from massage queue msgid
  receivelen = msgrcv(msgid, (void *)&amp;receiverbuffer, messagelen, 100, 0);

  printf("the receiverbuffer massage have %s .\n", receiverbuffer.message);
  printf("the long is %d .\n", receivelen);


  msgctl(msgid, IPC_RMID, NULL);

  system("ipcs -q");
  return 0;
}

</code></pre>
<pre><code class="language-example">
------ Nachrichtenwarteschlangen --------
Schlüssel msqid      Besitzer   Rechte     Benutzt-Bytes Nachrichten 
0x61091797 2          silin      777        0            0           
0x00000000 4          silin      777        0            0           
0x00000000 5          silin      777        0            0           
0x00000000 6          silin      777        0            0           
0x00000000 7          silin      777        0            0           
0x00000000 8          silin      777        0            0           
0x00000000 9          silin      777        0            0           
0x00000000 10         silin      777        0            0           
0x00000000 11         silin      777        0            0           
0x00000000 12         silin      777        0            0           

create massage queue success  with msgid 14.
please input your massage you want to send to massage queue 
the receiverbuffer massage have
the long is 6 .
</code></pre>
</li>
<li>
<p>semget</p>
<p>semid = semget(IPC~PRIVATE~,3 , 0777);</p>
</li>
<li>
<p>semctl</p>
<p>semctl(semid, 0, IPC~RMID~, NULL);</p>
</li>
</ol>
<h2 id="multi-thread"><a class="header" href="#multi-thread">Multi Thread</a></h2>
<h3 id="1-pthreadcreatec"><a class="header" href="#1-pthreadcreatec">1 pthread~create~.c</a></h3>
<p>using pthread~create~ create new thread(thread~fun~) with
arguements("new thread"). In new thread call function print~id~ with
giving arguements.</p>
<p>This programm can't compiled in Babel, please save this as a .c file,
and compile with <strong>-pthread</strong></p>
<pre><code class="language-{.c org-language=&quot;C&quot; results=&quot;output&quot; exports=&quot;both&quot;}">#include "apue.h"

void print_id(char *s)
{
  pid_t pid;
  pthread_t tid;

  pid = getpid();
  tid = pthread_self();

  printf("%s pid is %u, and tid is 0x%x\n", s, pid, (int) tid);
}

void *thread_fun(void *arg)
{
  printf("In son thread, can't get the father tid \n");

  print_id(arg);
  return (void *)0;
}

int main( )
{
  pthread_t ntid;
  int err;
  err = pthread_create(&amp;ntid, NULL, thread_fun, "new thread");

  if (err != 0) {
    printf("create new thread is failed\n");
    return 0;
  }
  printf("In father thread, the new THREAS is 0x%x \n", (int)ntid );

  print_id("main thread");
  sleep(2);

  return 0;
}


</code></pre>
<h3 id="2-pthreadidc"><a class="header" href="#2-pthreadidc">2 pthread~id~.c</a></h3>
<p>using pid = getpid() to get pid of current pthread</p>
<pre><code class="language-{.c org-language=&quot;C&quot; results=&quot;output&quot; exports=&quot;both&quot;}">#include &lt;stdio.h&gt;
#include "unistd.h"
#include "sys/types.h"
#include "stdlib.h"
#include "signal.h"
#include "sys/msg.h"
#include "string.h"

int main( )
{
  pid_t pid;
  pthread_t tid;

  pid = getpid();
  tid = pthread_self();

  printf("pid is %d , and tid is %x\n", pid, (int)tid );
  return 0;
}


</code></pre>
<pre><code class="language-example">pid is 3406 , and tid is 960c4c0
</code></pre>
<h3 id="3-pthreadjionc"><a class="header" href="#3-pthreadjionc">3 pthread~jion~.c</a></h3>
<p>pthread~jion~(tid, &amp;reval) 可以回收主线程发起的副线程tid，并由
副线程指定返回值给reval.但是副线程如自己调用了
pthread~detach~(pthread-self()) 可以阻止主线程的jion</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"

void *thread_fun1(void *arg){
  printf("New thread out with return\n");
  return (void *)1;
}

void *thread_fun2(void *arg){
  printf("New thread out with pthread_exit\n");
  pthread_detach(pthread_self()); // detach it self
  pthread_exit((void *)2);
}


int main( )
{
  pthread_t tid1, tid2;
  int err1, err2;
  void  *reval1, *reval2;

  err1 = pthread_create(&amp;tid1, NULL, thread_fun1, NULL); 
  err2 = pthread_create(&amp;tid2, NULL, thread_fun2, NULL); 

  if (err1 || err2) {
    printf("The create of new thread is failed\n");
  }

  printf("the thread 1 has return as %d\n", pthread_join(tid1, &amp;reval1) );
  printf("the thread 2 has return as %d\n", pthread_join(tid2, &amp;reval2) );

  printf("the thread 1 has return code %d\n",(int*)reval1 );
  printf("the thread 2 has return code %d\n",(int*)reval2 );

  return 0;
}



</code></pre>
<h3 id="4-pthreadcancelc"><a class="header" href="#4-pthreadcancelc">4 pthread~cancel~.c</a></h3>
<p>从主线程来的pthread~cancel~(tid)作用到tid的副线程时，
如果副线程设置为pthread~setcancelstate~(PTHREAD~CANCELDISABLE~, NULL)
则取消请求被忽视</p>
<p>如果副线程设置为pthread~setcancelstate~(PTHREAD~CANCELENABLE~, NULL);
则取消请求在下一个取消点被执行</p>
<p>如果副线程设置为pthread~setcanceltype~(PTHREAD~CANCELASYNCHRONOUS~,
NULL); 则取消请求被立即执行</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"

void *thread_fun(void * arg){
  int stateval;
  int typeval;

  //  set cancel to be disable
  stateval = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
  if (stateval != 0) {
    printf("set cancel state to disable is failed\n");
  }
  printf("I'm New thread here !\n");
  sleep(4);


  //set cancel to be enable, will be canceled at the first cancel point
  stateval = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
  if (stateval != 0)
    printf("set cancel state to enable is failed\n");
  else
    printf("about to set cancel enable\n");   // print is a cancel point

  //set cancel to be enable and immediately
  typeval = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
  if (typeval != 0) {
    printf("set cancel state to immediately failed\n");
  }

  //cancel points
  printf("first place to cancel:\n");
  printf("second place to cancel:\n");
  return (void *)20;
}



int main( )
{
  pthread_t tid;
  int err, cval, jval;
  void * rval;

  err = pthread_create(&amp;tid, NULL, thread_fun, NULL);
  if (err != 0) {
    printf("creat new thread is failed\n");
    return 0;
  }
  sleep(2);

  cval = pthread_cancel(tid);
  if (cval != 0) {
    printf("cancel the new thread is failed\n");
    return 0;
  }

  jval = pthread_join(tid, &amp;rval);
  if (jval != 0) {
    printf("join thread  is failed\n");
    return 0;
  }
  printf("new thread has return code of %d\n", (int) rval );

  return 0;
}

</code></pre>
<h3 id="5-pthreadrwlockc"><a class="header" href="#5-pthreadrwlockc">5 pthread~rwlock~.c</a></h3>
<p>pthread~rwlockt~ rwlock; 声明 pthread~rwlockinit~(&amp;rwlock); 初始化
pthread~rwlockwrlock~(&amp;rwlock); 写锁 pthread~rwlockrdlock~(&amp;rwlock);
读锁 pthread~rwlockunlock~(&amp;rwlock); 解锁
pthread~rwlockdestroy~(&amp;rwlock); 销锁</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"
int num;
pthread_rwlock_t rwlock;

void * thread_fun1(void *arg){
  int err;
  sleep(1);
  pthread_rwlock_wrlock(&amp;rwlock);  // write mode lock
  // pthread_rwlock_rdlock(&amp;rwlock);   // read mode lock

  printf("thread 1 print num as %d\n",num );
  sleep(5);
  printf("thread 1 is over \n");

  pthread_rwlock_unlock(&amp;rwlock);
  return (void *)0;
}

void * thread_fun2(void *arg){
  int err;
  pthread_rwlock_wrlock(&amp;rwlock);
  //  pthread_rwlock_rdlock(&amp;rwlock);

  printf("thread 2 print num as %d\n",num );
  sleep(5);
  printf("thread 2 is over \n");

  pthread_rwlock_unlock(&amp;rwlock);
  return (void *)0;
}

int main( )
{
  pthread_t tid1, tid2;
  int err;

  err = pthread_rwlock_init(&amp;rwlock, NULL);
  if (err) {
    printf("init failed\n");
    return 0;
  }

  err = pthread_create(&amp;tid1, NULL ,thread_fun1, NULL);
  if (err) {
    printf("create of the first thread fail\n");
    return 0;
  }

  err = pthread_create(&amp;tid2, NULL ,thread_fun2, NULL);
  if (err) {
    printf("create of the second thread failed\n");
    return 0;
  }

  pthread_join(tid1, NULL);
  pthread_join(tid2, NULL);

  pthread_rwlock_destroy(&amp;rwlock);

  return 0;
}




</code></pre>
<h3 id="6-pthreadattrc"><a class="header" href="#6-pthreadattrc">6 pthread~attr~.c</a></h3>
<p>seeing pthread~attr~.c pthread~attrinit~(&amp;attr) using :
pthread~attrsetdetachstate~(&amp;attr, PTHREAD~CREATEDETACHED~); OR:
pthread~attrsetdetachstate~(&amp;attr, PTHREAD~CREATEJOINABLE~);
决定该线程是否可以被jion.</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"

void *thread_fun1(void *arg)
{
  printf("I am new thread  1\n");
  return (void *)1;
}


void *thread_fun2(void *arg)
{
  printf("I am new thread  2 \n");
  return (void *)2;
}

int main(int argc, char *argv[])
{
  pthread_t tid1, tid2;
  int err;

  //def attr and init and set to be spreate
  pthread_attr_t attr;
  pthread_attr_init(&amp;attr);
  //  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);  

  err = pthread_create(&amp;tid1, &amp;attr, thread_fun1, NULL);
  if (err) {
    printf("create new thread 1 failed \n");
    return 0;
  }

  err = pthread_create(&amp;tid2, NULL, thread_fun2, NULL);
  if (err) {
    printf("create new thread 2 failed \n");
    return 0;
  }

  err = pthread_join(tid1, NULL);
  if (!err) 
    printf("join thread 1 success \n");
  else 
    printf("jion thread 1 failed \n");


  err = pthread_join(tid2, NULL);
  if (!err) 
    printf("join thread 2 success \n");
  else 
    printf("jion thread 2 failed \n");

  pthread_attr_destroy(&amp;attr);

  return 0;
}



</code></pre>
<h3 id="7-pthreadmutexc"><a class="header" href="#7-pthreadmutexc">7 pthread~mutex~.c</a></h3>
<p>pthread~mutexlock~(&amp;mutex) 和 pthread~mutexunlock~(&amp;mutex)
可以锁住之间的的任何变量， 所以不同线程之间的访问和赋值只能错开时间，
这样就不会造成线程之间变量值不受控制的错误</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"

struct student{
  int age;
  int size;
} stu;

int i;
pthread_mutex_t mutex;

void *thread_fun1(void *arg){
  while(1){
    //    pthread_mutex_lock(&amp;mutex);
    stu.age = i;
    stu.size = i;
    i++;
    if (stu.age != stu.size) {
      printf("thread 1 %d, %d,\n", stu.age, stu.size);
      break;
    }
    //    pthread_mutex_unlock(&amp;mutex);
  }
  return (void *)0;
}


void *thread_fun2(void *arg){
  while (1) {
    //    pthread_mutex_lock(&amp;mutex);
    stu.age = i;
    stu.size = i;
    i++;
    if (stu.age != stu.size) {
      printf("thread 2 %d, %d,\n", stu.age, stu.size);
    }
    //    pthread_mutex_unlock(&amp;mutex);
  }
  return(void *)0;
}

int main( )
{
  pthread_t tid1, tid2;
  int err1, err2;

  err1 = pthread_create(&amp;tid1, NULL, thread_fun1, NULL);
  err2 = pthread_create(&amp;tid2, NULL, thread_fun2, NULL);  
  if (err1 || err2) {
    printf("the create o pthread 1 and pthread 2 failed\n");
  }

  pthread_join(tid1, NULL);
  pthread_join(tid2, NULL);

  return 0;
}


</code></pre>
<h3 id="8-pthreadinterpetercontrollc"><a class="header" href="#8-pthreadinterpetercontrollc">8 pthread~interpetercontroll~.c</a></h3>
<p>用主线程给一个可交换变量赋值，来控制副进程的执行， only if in main
thread, parameter interpeter be assigned to 1, in side thread can start
to run.</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include &lt;stdio.h&gt;
#include "stdlib.h"
#include &lt;unistd.h&gt;
#include "pthread.h"

int interpeter = 0;

void *mythread(void *num){
  while(interpeter == 0);
  int i = 0;
  for (i = 0; i &lt; 10; ++i) {
    printf("In my thread there is %d\n", i);
    usleep(100);
  }
  return (void *)0;
}

int main(int argc, char *argv[])
{
  pthread_t tid;
  int err;
  err = pthread_create(&amp;tid, NULL, mythread, NULL);
  if (err &lt; 0) {
    printf("create my thread failed\n");
    return -1;
  }
  int i = 0;
  for (i = 0; i &lt; 10; ++i) {
    printf("In main thread there is %d\n", i);
    usleep(100);
  }
  interpeter = 1;
  sleep(10);
  return 0;
}



</code></pre>
<h3 id="9-pthreadpassstructc"><a class="header" href="#9-pthreadpassstructc">9 pthread~passstruct~.c</a></h3>
<p>将一个结构体通过pthread~create~()的参数传给副进程，注意在副进程中的
结构体转化</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"

struct student {
  int age;
  char name[10];
  char subject[10];
};

void *thread_fun(void *stu)
{
  printf("In the constuction we have age : %d, name : %s, and subject %s.\n", ((struct  student *)stu)-&gt;age,((struct student *)stu)-&gt;name, ((struct student *)stu)-&gt;subject);
  return (void *)0;
}

int main( )
{
  pthread_t tid;
  int err;
  void * val;

  struct student stu;
  stu.age = 20;
  memcpy(stu.name, "xiang", 10);
  memcpy(stu.subject, "phyics", 10);

  err = pthread_create(&amp;tid, NULL, thread_fun, (void *)&amp;stu);
  if (err != 0) {
    printf("the new thread is failed to create\n");
    return  0;
  }
  pthread_exit(val);
  return 0;
}





</code></pre>
<h3 id="10-pthreadstackattrc"><a class="header" href="#10-pthreadstackattrc">10 pthread~stackattr~.c</a></h3>
<p>在系统支持的条件下，获取栈的大小，并作出调整</p>
<pre><code class="language-{.c org-language=&quot;C&quot;}">#include "apue.h"

pthread_attr_t attr;

void *thread_fun(void *arg){

  size_t stacksize;

#ifdef _POSIX_THREAD_ATTR_STACKSIZE
  pthread_attr_getstacksize(&amp;attr, &amp;stacksize);
  printf("new thread stack size is %d \n", (int)stacksize );  //获取默认栈大小
  //更改 has to be greater than 16384, otherwise will be default
  pthread_attr_setstacksize(&amp;attr, 100000);
  pthread_attr_getstacksize(&amp;attr, &amp;stacksize);
  printf("new thread stack size is %d \n", (int)stacksize );  //获取设置栈大小
#endif // _POSIX_THREAD_ATTR_STACKSIZE


  return (void *)1;
}


int main(int argc, char *argv[])
{
  pthread_t tid;
  int err;

  pthread_attr_init(&amp;attr);

  //设置为可连接的分离属性
  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

  //check if system support this
#ifdef _POSIX_THREAD_ATTR_STACKSIZE
  pthread_attr_setstacksize(&amp;attr, PTHREAD_STACK_MIN);
#endif // _POSIX_THREAD_ATTR_STACKSIZE

  err = pthread_create(&amp;tid, &amp;attr, thread_fun, NULL);
  if (err) {
    printf("create new thread failed \n");
    return 0;
  }
  pthread_join(tid ,NULL);
  return 0;
}


</code></pre>
<h2 id="stoket"><a class="header" href="#stoket">Stoket</a></h2>
<h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="tips"><a class="header" href="#tips">tips</a></h2>
<pre><code>Raw 文件
git rm --cached file, will only delete it in git, but still in my local directory
</code></pre>
<h2 id="git-installation-in-linux"><a class="header" href="#git-installation-in-linux">Git installation in Linux</a></h2>
<ol>
<li>
<p>sudo apt install git</p>
</li>
<li>
<p>local configuration</p>
</li>
</ol>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">git  config --global user.name "username1"
git  config --global user.email "email1"
</code></pre>
<p>git config --list</p>
<ol>
<li>in local terminal</li>
</ol>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">ssh-keygen -t rsa -C "email2"
</code></pre>
<p>and then just all enter as default warming: email1 == email2</p>
<h2 id="webconfig"><a class="header" href="#webconfig">Webconfig</a></h2>
<pre><code>1. go to Fold Docu1, and in terminal git init to create local  repository
2. apply github count with:
   Email: email3
   Username: username3
   Password:xxxx
3. in setting add ssh key from local document: ./ssh/id_rsa.pub
4. create web repository with name Docu2
   Warming: Docu1 == Docu2
</code></pre>
<h2 id="connection"><a class="header" href="#connection">Connection</a></h2>
<pre><code>1. in local computer Docu1, create our files and prepare to push to
   Github
2. git add &amp;&amp; git commit -m ""
3. git remote add origin HTTPS/SSH(of the created web repository)
   warming: with  HTTPS will be ask the Username:username3 and
   password:xxxx every time for the push, but SSH note
4. git push -u origin master
5. username3 and xxxx if necessary
6. later push it only use git push origin master
</code></pre>
<h2 id="magit"><a class="header" href="#magit">Magit</a></h2>
<pre><code>C-x g  : open the git buffer
S or s : to stage
C      : to commit 
C-c C-c : to finish commit
P and p to push
</code></pre>
<h2 id="git-branch"><a class="header" href="#git-branch">Git branch</a></h2>
<h3 id="git-branch-创建development分支"><a class="header" href="#git-branch-创建development分支">git branch 创建development分支</a></h3>
<pre><code>branch 创建 新分支
创建新的分支： git branch development
带着全部家当去新的分支： git checkout development
git add -A 
git commit -m "development"
git push -u origin development
</code></pre>
<h3 id="git-merge-可以-merge-mybranch分支到master分支"><a class="header" href="#git-merge-可以-merge-mybranch分支到master分支">git merge 可以 merge mybranch分支到master分支</a></h3>
<pre><code>merge 融合分支
如果此时只有development分支改变，可以直接回到master, 把development分支
merge 过来   git merge development

git checkout master
git pull origin master
git branch --merged
git merge development
git push origin master
</code></pre>
<h3 id="删除mybranch分支"><a class="header" href="#删除mybranch分支">删除mybranch分支</a></h3>
<pre><code>git branch --merged
git branch -d mybrauch
git branch -a 
git push origin --delete mybrauch
</code></pre>
<h3 id="git-rm"><a class="header" href="#git-rm">git rm</a></h3>
<ol>
<li>
<p>git rm --cached file</p>
<pre><code>编辑当前文件后，已提交(已 add),想撤出索引 ：    git rm --cached  file
after that, I can check the delete file with git status or git diff --cached.
</code></pre>
</li>
<li>
<p>recover after git rm</p>
<pre><code>if I want , I can git add * to call all back again, but nothing to commit
</code></pre>
</li>
<li>
<p>confirm to delete file in local directory</p>
<pre><code>if I ready want to delete this,
using rm file  delete the file in local directory, 
but git status and diff --cached remands this still, 
only after commit, there's no signal for the deleted file anymore.
</code></pre>
</li>
<li>
<p>recover after delete in local directory</p>
<pre><code>git reflog
git reset --hard ID
</code></pre>
</li>
</ol>
<h3 id="git-multi-commit"><a class="header" href="#git-multi-commit">git multi commit</a></h3>
<p>commit 添加提交 和上次commit提交融合，不产生新的提交记录： git commit
--amend</p>
<h3 id="remote-branch"><a class="header" href="#remote-branch">remote branch</a></h3>
<pre><code>git checkout -t origin/ui-mockup
</code></pre>
<h2 id="commands-to-recover"><a class="header" href="#commands-to-recover">commands to recover</a></h2>
<h3 id="after-only-save"><a class="header" href="#after-only-save">after only save</a></h3>
<hr />
<p>git diff               can see the different comparing to last time commit
git checkout -- file   git diff: NULL, file has been recovered</p>
<hr />
<h3 id="after-git-add-file"><a class="header" href="#after-git-add-file">after git add file</a></h3>
<hr />
<p>git diff               dit diff :NULL
git diff --cached      can see the different comparing to the last time commit
git reset HEAD file    git diff -- cached : NULL
git checkout -- file   file has been recovered</p>
<hr />
<h3 id="after-git-commit-file"><a class="header" href="#after-git-commit-file">after git commit file</a></h3>
<pre><code>编辑后，强制回到最近一次添加索引的版本：        git reset --hard HEAD
编辑后，强制回到最近倒数第二次添加索引的版本：   git reset --hard HEAD~
编辑后，强制回到最近倒数第n次添加索引的版本：    git reset --hard HEAD~n

如果将HEAD换成对应的ID， 也可以回到之前相应的版本。 但是如果想再回去，
又没有记住之前的ID， 可以用，       git reflog 查询.
</code></pre>
<h1 id="gwdg"><a class="header" href="#gwdg">GWDG</a></h1>
<ol>
<li>as student of Göttingen send email to support@gwdg.de with uni
email, asking for freischaltung of cloud server</li>
<li>got <a href="https://gwdg.de">https://gwdg.de</a> Dienst-&gt; GWDG cloud server -&gt; self service
create Instance if with my ssh, the connect can be without password,
but still need to aktiv</li>
<li>where the instance is created, use the VNS to aktiv the konto,
remember to save the password ssh cloud@ip</li>
</ol>
<h1 id="google-cloud"><a class="header" href="#google-cloud">Google cloud</a></h1>
<h1 id="certificate"><a class="header" href="#certificate">Certificate</a></h1>
<ul>
<li>
<p>First generate the self-singed certificate: Set CN to localhost,</p>
<pre><code>openssl req -new -x509 -nodes -keyout key.pem -sha256 -days 365 -out cert.pem
sudo cp cert.pem /etc/pki/ca-trust/source/anchors/
sudo update-ca-trust
</code></pre>
</li>
<li>
<p>First generate a new key, and Then create a CSR from it:</p>
<pre><code>openssl genrsa -out test.key 2048
openssl req -new -key test.key -out test.csr
</code></pre>
</li>
<li>
<p>creat extenation file test.ext, for domain name or DNS</p>
<pre><code>1 authorityKeyIdentifier=keyid,issuer
2 basicConstraints=CA:FALSE
3 keyUsage =digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
4 subjectAltName = @alt_names
5
6 [alt_names]
7 DNS.1 = localhost
8 DNS.2 = test.dev
</code></pre>
</li>
<li>
<p>Create a new signed certificate for extended information</p>
<pre><code>openssl x509 -req -in test.csr -CA cert.pem -CAkey key.pem -CAcreateserial \
-out test.crt -days 365 -sha256 -extfile test.ext    
</code></pre>
</li>
<li>
<p>signed by Let's Encrypt</p>
<pre><code>sudo certbot certonly --standalone
</code></pre>
</li>
<li>
<p>DONe</p>
</li>
</ul>
<h1 id="problem"><a class="header" href="#problem">Problem</a></h1>
<h2 id="system-limit-for-number-of-file-watchers-reached"><a class="header" href="#system-limit-for-number-of-file-watchers-reached">System limit for number of file watchers reached</a></h2>
<p>sudo sysctl -w fs.inotify.max~userwatches~=100000 reboot</p>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">ls
</code></pre>
<h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<pre><code class="language-{.bash org-language=&quot;sh&quot;}">sudo docker rm $(sudo docker ps -aq)
sudo docker rmi $(sudo docker images -aq)
</code></pre>
<h1 id="opencv"><a class="header" href="#opencv">opencv</a></h1>
<p>sudo cmake
-DCMAKE~INSTALLPREFIX~:PATH=/home/si/Dokumente/opencv/libopencv .. make
make install export
LD~LIBRARYPATH~=$LD~LIBRARYPATH~:/home/si/Dokumente/opencv/libopencv/lib</p>
<h1 id="warp"><a class="header" href="#warp">Warp</a></h1>
<hr />
<p>Ctrl f   move cousur to left, accept the auto complete
Ctrl N   next block
Ctrl P   provious block</p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="CS.org.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Algorithm.org.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="CS.org.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Algorithm.org.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
