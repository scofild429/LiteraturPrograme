#+TITLE:  Go
#+OPTIONS: num:nil
#+STARTUP: overview
* print
#+begin_src go :results output :exports both
  package main
  import "fmt"
  func main() {
      a := [...]int{1,2,3,4,5}
      b := a
      b[1] = 50
      fmt.Println(a)
      fmt.Println(b)
  }
#+end_src

#+RESULTS:
: [1 2 3 4 5]
: [1 50 3 4 5]

* time
#+begin_src go :results output :exports both
  package main
  import (
      "fmt"
      "time"
  )
  func test() {
      start := time.Now()
      sum := 0
      for i := 0; i < 100000; i++ {
          sum++
      }
      elapsed := time.Since(start)
      fmt.Println("该函数执行完成耗时：", elapsed)
  }

  func main() {
      test()
  }

#+end_src

#+RESULTS:
: 该函数执行完成耗时： 33.536µs

* sync
#+begin_src go :results output :exports both
  package main
  import (
      "fmt"
      "time"
      "sync"
  )
  func main() {
      var wg sync.WaitGroup
      wg.Add(1)

      go func(){
          count("Sleep")
          wg.Done()
      }()
      wg.Wait()
  }

  func count(thing string) {
      for i := 1; i <= 5; i++ {
          fmt.Println(i, thing)
          time.Sleep(time.Millisecond*500)
      }

  }
#+end_src

#+RESULTS:
: 1 Sleep
: 2 Sleep
: 3 Sleep
: 4 Sleep
: 5 Sleep

* go
#+begin_src go :results output :exports both
  package main
  import (
      "fmt"
      "time"
  )
  func main() {
      var times int
      go func() {
          for {
          }
      }()
      go func() {
          for {
          }
      }()
      go func() {
          for {
          }
      }()
      go func() {
          for {
          }
      }()
      for times = 0; times <= 10; times++ {
          fmt.Println("tick", times)
          time.Sleep(time.Second)
      }
  }

#+end_src

#+RESULTS:
#+begin_example
tick 0
tick 1
tick 2
tick 3
tick 4
tick 5
tick 6
tick 7
tick 8
tick 9
tick 10
#+end_example

* chan
#+begin_src go :results output :exports both
  package main
  import "fmt"
  func main() {
      // 创建一个整型带两个缓冲的通道
      ch := make(chan int, 2)
	
      // 给通道放入两个数据
      ch <- 0
      ch <- 1
	
      // 关闭缓冲
      close(ch)
      // 遍历缓冲所有数据, 且多遍历1个
      for i := 0; i < cap(ch)+1; i++ {
		
          // 从通道中取出数据
          v, ok := <-ch
		
          // 打印取出数据的状态
          fmt.Println(v, ok)
      }
  }
#+end_src

#+RESULTS:
: 0 true
: 1 true
: 0 false

* context
:PROPERTIES:
:ID:       2bf1c325-6a98-43be-815c-a41934b02756
:END:

#+begin_src  go :results output :exports both
  package main

  import (
      "fmt"
      "context"
      "time"
  )

  func enrichContext(ctx context.Context) context.Context {
      return context.WithValue(ctx, "request-id", "11212")

  }

  func doSomething(ctx context.Context){
      rID := ctx.Value("request-id")
      fmt.Println(rID)
      for {
          select {
          case <-ctx.Done():
              fmt.Println("times out")
              return
          default:
              fmt.Println("doing something cool")
          }
          time.Sleep(500*time.Millisecond)
      }
  }


  func main (){
      fmt.Println("Go Context example")
      ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
      defer cancel()
      fmt.Println(ctx.Err())
      ctx = enrichContext(ctx)
      go doSomething(ctx)
      select {
      case <- ctx.Done():
          fmt.Println("Oh, no, Time is execeed the deadline")
          fmt.Println(ctx.Err())
      }
      time.Sleep(2*time.Second)
  }
#+end_src

#+RESULTS:
#+begin_example
Go Context example
<nil>
11212
doing something cool
doing something cool
doing something cool
doing something cool
Oh, no, Time is execeed the deadline
context deadline exceeded
times out
#+end_example

* gonum
** Test example
#+begin_src go :results output :exports both :tangle ./babel/main.go
  package main

  import (
          "fmt"

          "gonum.org/v1/gonum/blas/blas64"
          "gonum.org/v1/gonum/mat"
  )

  func main() {
          r := row{1, 2, 3, 4}
          c := column{1, 2, 3}

          var m mat.Dense
          m.Mul(c, r)

          fmt.Println(mat.Formatted(&m))
          n := c.RawVector().N
          inc := c.RawVector().Inc
          d := c.RawVector().Data
          fmt.Println(n)
          fmt.Println(inc)
          fmt.Println(d)

          u := mat.NewVecDense(3, []float64{1, 2, 3})
          v := mat.NewVecDense(3, []float64{4, 5, 6})
          fmt.Println("u :", u)
          fmt.Println("v :", v)

  }

  // row is a user-defined row vector.
  type row []float64

  // Dims, At and T minimally satisfy the mat.Matrix interface.
  func (v row) Dims() (r, c int)    { return 1, len(v) }
  func (v row) At(_, j int) float64 { return v[j] }
  func (v row) T() mat.Matrix       { return column(v) }

  // RawVector allows fast path computation with the vector.
  func (v row) RawVector() blas64.Vector {
          return blas64.Vector{N: len(v), Data: v, Inc: 1}
  }

  // column is a user-defined column vector.
  type column []float64

  // Dims, At and T minimally satisfy the mat.Matrix interface.
  func (v column) Dims() (r, c int)    { return len(v), 1 }
  func (v column) At(i, _ int) float64 { return v[i] }
  func (v column) T() mat.Matrix       { return row(v) }

  // RawVector allows fast path computation with the vector.
  func (v column) RawVector() blas64.Vector {
          return blas64.Vector{N: len(v), Data: v, Inc: 1}
  }

#+end_src

#+RESULTS:

** NewDense
#+begin_src go :tangle ./babel/main.go
  package main

  import (
          "fmt"
          "gonum.org/v1/gonum/mat"
  )

  func main() {
          zeros := mat.NewDense(3,5,nil)
          fmt.Println(zeros)
  }

#+end_src

#+RESULTS:

** make
#+begin_src go :tangle ./babel/main.go
  package main

  import (
          "fmt"
          "math/rand"
          "gonum.org/v1/gonum/mat"
  )

  func main() {
          data := make([]float64, 36)
          for i := range data {
                  data[i] = rand.NormFloat64()
          }
          a := mat.NewDense(6, 6, data)
          zeros := mat.NewDense(3,5,nil)
          // fmt.Println(mat.Formatted(zeros, mat.Prefix(""), mat.Squeeze()))
          // fmt.Println(mat.Formatted(a, mat.Prefix(""), mat.Squeeze()))
          eq := mat.Equal(a, zeros)
          fmt.Println(eq)

  }

#+end_src

** gonum execute  
#+begin_src sh :results output :exports both
  cd babel
  go mod init babel-go
  go mod tidy
  go build main.go
  rm main.go
  rm go.mod
  rm go.sum
  ./main
#+end_src

#+RESULTS:
: false

* PatternDesign
** Observer
#+begin_src go :results output :exports both
  package main

  import (
          "fmt"
          "sync"
          "time"
  )

  type (
          eventObserver struct {
                  id   int
                  time time.Time
          }
          eventSubject struct {
                  observers sync.Map
          }
          Event struct {
                  data int
          }
          Observer interface {
                  NotifyCallback(Event)
          }
          Subject interface {
                  AddListener(Observer)
                  RemoveListener(Observer)
                  Notify(Event)
          }
  )

  // NotifyCallback ...
  func (e *eventObserver) NotifyCallback(event Event) {
          fmt.Printf("Observer: %d Recieved: %d after %v\n", e.id, event.data, time.Since(e.time))
  }

  // AddListener ...
  func (s *eventSubject) AddListener(obs Observer) {
          s.observers.Store(obs, struct{}{})
  }

  // RemoveListener ...
  func (s *eventSubject) RemoveListener(obs Observer) {
          s.observers.Delete(obs)
  }

  // Notify  ...
  func (s *eventSubject) Notify(event Event) {
          s.observers.Range(func(key interface{}, value interface{}) bool {
                  fmt.Printf("%T", key)
                  if key == nil || value == nil {
                          return false
                  }
                  key.(Observer).NotifyCallback(event)
                  return true
          })
  }

  func fib(n int) chan int {
          out := make(chan int)
          go // name ...
          func() {
                  defer close(out)
                  for i, j := 0, 1; i < n; i, j = i+j, i {
                          out <- i
                  }
          }()
          return out
  }

  func main() {
          n := eventSubject{
                  observers: sync.Map{},
          }
          var obs1 = eventObserver{id: 1, time: time.Now()}
          var obs2 = eventObserver{id: 2, time: time.Now()}

          n.AddListener(&obs1)
          n.AddListener(&obs2)
          n.AddListener(&eventObserver{id: 3, time: time.Now()})

          go func() {
                  select {
                  case <-time.After(time.Millisecond):
                          n.RemoveListener(&obs2)
                  }
          }()

          for x := range fib(1000000000000000000) {
                  n.Notify(Event{data: x})
          }
  }

#+end_src
** Factory
#+begin_src go :results output :exports both
  package main

  import (
          "fmt"
          "reflect"
  )

  type (
          mongoDB struct {
                  database map[string]string
          }
          sqlite struct {
                  database map[string]string
          }
          Database interface {
                  GetData(string) string
                  PutData(string, string)
          }
          file struct {
                  name    string
                  content string
          }
          ntfs struct {
                  files map[string]file
          }
          ext4 struct {
                  files map[string]file
          }
          FileSystem interface {
                  CreateFile(string)
                  FindFile(string) file
          }

          Factory func(string) interface{}
  )

  func (mdb mongoDB) GetData(query string) string {
          if _, ok := mdb.database[query]; !ok {
                  return ""
          }
          fmt.Println("MongoDB")
          return mdb.database[query]
  }

  func (mdb mongoDB) PutData(query string, data string) {
          mdb.database[query] = data
  }

  func (sql sqlite) GetData(query string) string {
          if _, ok := sql.database[query]; !ok {
                  return ""
          }
          fmt.Println("Sqlite")
          return sql.database[query]
  }

  func (sql sqlite) PutData(query string, data string) {
          sql.database[query] = data
  }

  func (ntfs ntfs) CreateFile(path string) {
          file := file{content: "NTFS file", name: path}
          ntfs.files[path] = file
          fmt.Println("NTFS")
  }

  func (ext ext4) CreateFile(path string) {
          file := file{content: "EXT4 file", name: path}
          ext.files[path] = file
          fmt.Println("EXT4")
  }

  func (ntfs ntfs) FindFile(path string) file {
          if _, ok := ntfs.files[path]; !ok {
                  return file{}
          }
          return ntfs.files[path]
  }

  func (ext ext4) FindFile(path string) file {
          if _, ok := ext.files[path]; !ok {
                  return file{}
          }
          return ext.files[path]
  }

  // DatabaseFactory ...
  func DatabaseFactory(env string) interface{} {
          switch env {
          case "production":
                  return mongoDB{
                          database: make(map[string]string),
                  }
          case "development":
                  return sqlite{
                          database: make(map[string]string),
                  }
          default:
                  return nil
          }
  }

  func FilesystemFactory(env string) interface{} {
          switch env {
          case "production":
                  return ntfs{
                          files: make(map[string]file),
                  }
          case "development":
                  return ext4{
                          files: make(map[string]file),
                  }
          default:
                  return nil
          }
  }

  // AbstractFactoryy ...
  func AbstractFactory(fact string) func(string) interface{} {
          switch fact {
          case "database":
                  return DatabaseFactory
          case "filesystem":
                  return FilesystemFactory
          default:
                  return nil
          }
  }

  func SetupConstructors(env string) (Database, FileSystem) {
          fs := AbstractFactory("filesystem")
          db := AbstractFactory("database")
          return db(env).(Database), fs(env).(FileSystem)

  }

  func main() {
          env1 := "production"
          env2 := "development"

          // db1 := DatabaseFactory(env1)
          // db2 := DatabaseFactory(env2)

          db1, fs1 := SetupConstructors(env1)
          db2, fs2 := SetupConstructors(env2)

          db1.PutData("test", "for test")
          fmt.Println(db1.GetData("test"))
          db2.PutData("test2", "for test2")
          fmt.Println(db2.GetData("test2"))

          fs1.CreateFile("../example/fts.txt")
          fmt.Println(fs1.FindFile("../example/fts.txt"))

          fs2.CreateFile("../example/et4.txt")
          fmt.Println(fs2.FindFile("../example/et4.txt"))

          fmt.Println(reflect.TypeOf(db1).Name())
          fmt.Println(reflect.TypeOf(&db1).Elem())
          fmt.Println(reflect.TypeOf(db2).Name())
          fmt.Println(reflect.TypeOf(&db2).Elem())

          fmt.Println(reflect.TypeOf(fs1).Name())
          fmt.Println(reflect.TypeOf(&fs1).Elem())
          fmt.Println(reflect.TypeOf(fs2).Name())
          fmt.Println(reflect.TypeOf(&fs2).Elem())
  }

#+end_src

#+RESULTS:
#+begin_example
MongoDB
for test
Sqlite
for test2
NTFS
{../example/fts.txt NTFS file}
EXT4
{../example/et4.txt EXT4 file}
mongoDB
main.Database
sqlite
main.Database
ntfs
main.FileSystem
ext4
main.FileSystem
#+end_example

** Decorator
#+begin_src go :results output :exports both
  package main

  import (
          "fmt"
          "log"
          "math"
          "os"
          "sync"
          "time"
  )

  func Pi(n int) float64 {
          ch := make(chan float64)
          for k := 0; k <= n; k++ {
                  go func(ch chan float64, k float64) {
                          ch <- 4 * math.Pow(-1, k) / (2*k + 1)
                  }(ch, float64(k))
          }
          result := 0.0
          for k := 0; k <= n; k++ {
                  result += <-ch
          }
          return result
  }

  type piFunc func(int) float64

  func wraplogger(fun piFunc, logger *log.Logger) piFunc {
          return func(n int) float64 {
                  fn := func(n int) (result float64) {
                          defer func(t time.Time) {
                                  logger.Printf("took=%v, v=%v, result=%v", time.Since(t), n, result)
                          }(time.Now())
                          return fun(n)
                  }
                  return fn(n)
          }
  }

  func wrapcache(fun piFunc, cache *sync.Map) piFunc {
          return func(n int) float64 {
                  fn := func(n int) float64 {
                          key := fmt.Sprintf("n=%d", n)
                          val, ok := cache.Load(key)
                          if ok {
                                  return val.(float64)
                          }
                          result := fun(n)
                          cache.Store(key, result)
                          return result
                  }
                  return fn(n)
          }
  }

  func divide(n int) float64 {
          return float64(n / 2)
  }

  func main() {
          // 01
          // fmt.Println(Pi(1000))
          // fmt.Println(Pi(50000))
          // 02
          //f := wraplogger(Pi, log.New(os.Stdout, "test", 1))
          // f(10000)
          //03
          f := wrapcache(Pi, &sync.Map{})
          g := wraplogger(f, log.New(os.Stdout, "test", 1))
          g(100000)
          g(200000)
          g(500000)
          g(500000)
          // 04
          f = wrapcache(divide, &sync.Map{})
          g = wraplogger(f, log.New(os.Stdout, "divide", 1))
          g(100000)
          g(200000)
          g(500000)
          g(500000)
  }


#+end_src

#+RESULTS:
: test2022/07/12 took=197.241951ms, v=100000, result=3.1416026534897195
: test2022/07/12 took=326.435601ms, v=200000, result=3.1415976535647596
: test2022/07/12 took=678.005443ms, v=500000, result=3.1415946535856927
: test2022/07/12 took=2.673µs, v=500000, result=3.1415946535856927
: divide2022/07/12 took=15.404µs, v=100000, result=50000
: divide2022/07/12 took=3.475µs, v=200000, result=100000
: divide2022/07/12 took=1.724µs, v=500000, result=250000
: divide2022/07/12 took=922ns, v=500000, result=250000


* Architecture
** package
each folder can only has one named package,
but it can be shared for many files, also for the test file
** module
it is the same designed as project, but only without main function and main package.
it can be used by local package, module or project, but has to be replaced
#+begin_src
go mod edit -replace modulename=folder  
#+end_src
- modul name is defined in the go.mod file, and also at last one package should named as it
- floder can be relative path, or absolute path in the reference package, module or project.
- can be called from gore, but first :import  
** project
- the same with module, with main package and main func, can be call as go run xxx.go
- can not  be called from gore for now (29.07.2022)

